# WIP-01

## `did:web5` Method Specification

`draft` `mandatory`

This document defines the `did:web5` method, a Decentralized Identifier (DID) method specification that utilizes the Nervos CKB (Common Knowledge Base) blockchain for creating, updating, and deactivating DIDs. The method is designed to provide decentralized identity management with strong consistency, cryptographic verifiability, and blockchain-based persistence.

## 1. Introduction

The `did:web5` method leverages the Nervos CKB blockchain to provide a decentralized identity infrastructure. CKB uses a UTXO-based Cell model that enables flexible state storage and computation verification. This method provides strong consistency guarantees through blockchain consensus while maintaining compatibility with existing DID ecosystems. A simple introduction to the Cell model can be found in the appendix.

The did:web5 method aims to achieve:

- **Decentralization**: No dependency on centralized authorities
- **Persistence**: Long-term storage on blockchain infrastructure
- **Verifiability**: Cryptographic proof of DID operations
- **Interoperability**: Compatibility with W3C DID standards
- **Flexibility**: Support for various cryptographic schemes

## 2. Method Syntax

### 2.1 Method Name

A DID that uses this method MUST begin with the prefix `did:web5:` followed by the method-specific identifier. An example DID is:

```
did:web5:qq2m72a2vas4e5ovcpxoedscguuu4nba
```

### 2.2 Method-Specific Identifier Generation

A did:web5 identifier MUST be generated through the following process:

1. Build a CKB transaction that creates a DID Document Cell
2. Extract the unique characteristics of the transaction and the position of the DID Document Cell
3. Hash these components to generate the method-specific identifier

### 2.2.1 Hash Input Components

The method-specific identifier MUST be generated by hashing the following binary sequence in order:

1. `inputs[0].since`: 8 bytes (the `since` field of the first input)
2. `inputs[0].previous_output.tx_hash`: 32 bytes (Hash of transaction that creates the first input)
3. `inputs[0].previous_output.index`: 4 bytes (Output Index of the first input in the transaction that creates it, little-endian 32-bit integer, zero-based index)
4. DID Document Cell Output Index: 8 bytes (little-endian 64-bit integer, zero-based index)

### 2.2.2 Hash Algorithm

The concatenated input MUST be hashed using BLAKE2b ([BLAKE2]) with the following parameters:

- Personalization: `ckb-default-hash`
- Output length: 32 bytes

The first 20 bytes of the hash result is used as the method-specific identifier

### 2.2.3 Text Encoding

The 20-byte hash result MUST be encoded using base32 ([RFC4648]) with lowercase letters only, resulting in a 32-character method-specific identifier.

Example:

```
did:web5:qq2m72a2vas4e5ovcpxoedscguuu4nba
```

### 2.2.4 Illustration

[https://link.excalidraw.com/readonly/d5YMLFu6Hb6qsScNcUFW](https://link.excalidraw.com/readonly/d5YMLFu6Hb6qsScNcUFW)

### 2.3 Method-Specific Identifier Syntax

The method-specific identifier MUST conform to the following constraints:

- Total length: exactly 32 characters
- Character set: lowercase letters `a-z` and digits `2-7` (base32 alphabet)
- Case sensitivity: case-insensitive, MUST be normalized to lowercase

### 2.4 Uniqueness Requirements

The method-specific identifier MUST be unique within the `did:web5` method space. Uniqueness is guaranteed by:

1. The cryptographic hash function (BLAKE2b) producing collision-resistant outputs
2. The requirement that each Cell can only be consumed once in CKB transactions
3. The inclusion of the DID document cell output index in the hash input

## 3. Method Operations

### 3.1 Authorization

DID creation is permissionless and anyone can create a new DID by locking CKB tokens equal to the storage size.

DID update and deactivation operations MUST be authorized through CKB's Lock Script mechanism. The Lock Script defines the ownership and authorization requirements for DID Document Cells.

Supported authorization mechanisms include:

- secp256k1 signature verification
- Multi-signature schemes
- Custom cryptographic verification methods
- Cross-chain authorization (e.g., RGB++)

### 3.2 Create

### 3.2.1 Creation Process

To create a new `did:web5` DID:

1. A user MUST provide a DID Document and Lock Script for future update authorization to a did:web5 controller
2. The controller MUST construct a CKB transaction that creates a DID Document Cell
3. The transaction MUST be signed by the transaction input CKB tokens owner
4. The transaction MUST be submitted to the CKB network for consensus
5. The DID Document Cell Type Script MUST validate the update operation

### 3.2.2 DID Document Cell Structure

The DID Document Cell MUST have the following structure:

- **Capacity**: Sufficient CKB tokens to cover storage requirements (typically ~600 CKB plus reserves). These CKB tokens come from the transaction inputs.
- **Lock Script**: Defines ownership and authorization for the DID future updates.
- **Type Script**: MUST use the designated did:web5 Type Script (`did-web5-ts`) with:
    - `args`: The 20-byte method-specific identifier in binary form
- **Data**: MUST contain a Molecule-encoded ([MOLECULE]) `DidWeb5Data` structure

### 3.2.3 Data Structure

The Cell data MUST conform to the following Molecule schema:

```mol
vector Bytes <byte>;
vector String <byte>; // UTF-8 encoded
option StringOpt (String);

table DidWeb5DataV1 {
    document: Bytes,
    local_id: StringOpt,
}

union DidWeb5Data {
    DidWeb5DataV1,
}
```

Where:

- `document`: DAG-CBOR ([DAG-CBOR]) encoded DID Document JSON object
- `local_id`: Reserved for future usage

### 3.2.4 DID Document Format

The DID Document SHALL use the following fields compatible with did:plc ([DID-PLC]) operation format:

- `verificationMethods` (map): Public key mappings in did:key encoding
- `alsoKnownAs` (array): Alternative identifiers/aliases
- `services` (map): Service endpoint definitions

The DID Document SHALL NOT include PLC-specific fields:

- `type`
- `rotationKeys`
- `prev`
- `sig`

### 3.2.5 Creation Validation

The did-web5-ts Type Script MUST verify:

1. No DID Document Cell is consumed as input
2. Exactly one DID Document Cell is created as output
3. The DID Document Cell Type Script args MUST equal to the identifier generated by the algorithm described in 2.2
4. The new Cell data follows the required format as described in 3.2.2
5. Extension field constraints MUST be satisfied. See Chapter 4.

The did-web5-ts Type Script SHOULD verify:

- The DID Document saved in the `document` field of the DID Document Cell SHOULD conform the format described in 3.2.4

### 3.3 Resolve

### 3.3.1 Resolution Process

To resolve a did:web5 identifier, the resolver MUST:

1. Convert the method-specific identifier from base32 to 20 bytes
2. Search for Live Cells matching the Type Script and args
3. If multiple cells found, apply conflict resolution (see 3.3.2)
4. Extract the `document` field from the Cell data
5. Decode the DAG-CBOR content to JSON
6. Transform to standard DID Document format

### 3.3.2 Conflict Resolution

If multiple Live Cells exist for the same method-specific identifier:

1. Trace each Cell to its genesis transaction which creates the first version of the DID document cell.
2. Order by transaction position in the blockchain, then the Cell position in the transaction outputs.
3. Select the earliest created Cell as authoritative
4. MAY return an error for conflicting states

### 3.4 Update

### 3.4.1 Update Process

To update a did:web5 DID:

1. A user MUST provide the DID, new DID Document, and updated Lock Script to a did:web5 controller.
2. The controller MUST construct a transaction that:
    - Consumes the current DID Document Cell (input)
    - Creates a new DID Document Cell with the same method-specific identifier (output)
3. Transaction MUST be authorized by the current Lock Script
4. The transaction MUST be submitted to the CKB network for consensus
5. The DID Document Cell Type Script MUST validate the update operation

### 3.4.2 Update Validation

The did-web5-ts Type Script MUST verify:

1. Exactly one DID Document Cell is consumed as input
2. Exactly one DID Document Cell is created as output
3. Both cells use the same method-specific identifier
4. The new Cell data follows the required format as described in 3.2.2
5. Extension field constraints MUST be satisfied. See Chapter 4.

### 3.5 Deactivate

### 3.5.1 Deactivation Process

To deactivate a did:web5 DID:

1. A user MUST provide the DID to a did:web5 controller
2. Controller constructs a transaction that consumes the DID Document Cell without creating a replacement
3. Transaction MUST be authorized by the current Lock Script
4. The transaction MUST be submitted to the CKB network for consensus
5. The DID Document Cell Type Script MUST validate the update operation

Applications MUST warn users that deactivation is permanent and irreversible.

### 3.5.2 Deactivation Validation

The did-web5-ts Type Script MUST verify:

1. Exactly one DID Document Cell is consumed as input
2. No DID Document Cell with the same method-specific identifier is created as output

### 3.6 Example

### 3.6.1 Creation Example

Example transaction that creates `did:web5:qq2m72a2vas4e5ovcpxoedscguuu4nba`.

```jsx
{
  "cellDeps": [
    // did-web5-ts for outptus[0].type
    {
      "depType": "code",
      "outPoint": {
        "index": "0x0",
        "txHash": "0x1ecbf88d692a14d7cbc0bfd1a3d5019e4b613247ae438bad52f94148c6009559",
      },
    },
    // always-success for inputs[0].lock
    {
      "depType": "code",
      "outPoint": {
        "index": "0x1",
        "txHash": "0x1ecbf88d692a14d7cbc0bfd1a3d5019e4b613247ae438bad52f94148c6009559",
      },
    },
  ],
  "headerDeps": [],
  "inputs": [
    // Input that provides capacity for the output.
    {
      "previousOutput": {
        "index": "0x2",
        "txHash": "0x1ecbf88d692a14d7cbc0bfd1a3d5019e4b613247ae438bad52f94148c6009559",
      },
      "since": "0x0",
    },
  ],
  "outputs": [
    // The new created DID Document Cell
    {
      "capacity": "0x258",
      "lock": {
        "args": "0x",
        "codeHash": "0x3dc9cdb5b2dcff8d4999004406558d4456ecf0f14c757ca353684c0bd4d3b50d",
        "hashType": "type",
      },
      "type": {
        "args": "0x8434cfe81aa825c275d513eee20e4235294e3420",
        "codeHash": "0xb95123c71a870e3f0f74a7ee1dab8268dbfbc1407b46733ebd1b41f854b4324a",
        "hashType": "type",
      },
    },
  ],
  "outputsData": [
    "0x00000000b40000000c000000b4000000...",
  ],
  "version": "0x0",
  "witnesses": [],
}
```

The DID Document Cell data has been truncated for better display of this document.

The full content of the data is:

```
0x
00000000b40000000c000000b4000000a4000000a3687365727669636573a16b
617470726f746f5f706473a264747970657819417470726f746f506572736f6e
616c4461746153657276657268656e64706f696e747468747470733a2f2f6578
616d706c652e746573746b616c736f4b6e6f776e4173816f61743a2f2f616c69
63652e7465737473766572696669636174696f6e4d6574686f6473a167617470
726f746f736469643a6b65793a7a5369676e696e674b6579
```

It is the Molecule encoding of `DidWeb5Data` using `DidWeb5DataV1` that `local_id` is `None` and `document` is the DAG-CBOR encoding of the following JSON object:

```jsx
{
  "verificationMethods": {
    "atproto": "did:key:zSigningKey"
  },
  "alsoKnownAs": ["at://alice.test"],
  "services": {
    "atproto_pds": {
      "type": "AtprotoPersonalDataServer",
      "endpoint": "<https://example.test>"
    }
  }
}
```

### 3.6.2 Update Example

Example transaction that updates `did:web5:qq2m72a2vas4e5ovcpxoedscguuu4nba`.

```jsx
{
  "cellDeps": [
    // did-web5-ts for inputs[0].type and outptus[0].type
    {
      "depType": "code",
      "outPoint": {
        "index": "0x0",
        "txHash": "0x1ecbf88d692a14d7cbc0bfd1a3d5019e4b613247ae438bad52f94148c6009559",
      },
    },
    // always-success for inputs[0].lock
    {
      "depType": "code",
      "outPoint": {
        "index": "0x1",
        "txHash": "0x1ecbf88d692a14d7cbc0bfd1a3d5019e4b613247ae438bad52f94148c6009559",
      },
    },
  ],
  "headerDeps": [],
  "inputs": [
    // Input DID Document Cell, created in the Creation Example
    {
      "previousOutput": {
        "index": "0x0",
        "txHash": "0xe54bb705cea6e500767ed4c0ba9ee92cad71e6b39c55283591147c5d10cc12b5",
      },
      "since": "0x0",
    },
  ],
  "outputs": [
    // Updated DID DID Document Cell
    {
      "capacity": "0x257",
      "lock": {
        "args": "0x",
        "codeHash": "0x3dc9cdb5b2dcff8d4999004406558d4456ecf0f14c757ca353684c0bd4d3b50d",
        "hashType": "type",
      },
      "type": {
        "args": "0x8434cfe81aa825c275d513eee20e4235294e3420",
        "codeHash": "0xb95123c71a870e3f0f74a7ee1dab8268dbfbc1407b46733ebd1b41f854b4324a",
        "hashType": "data2",
      },
    },
  ],
  "outputsData": [
    "0x00000000b20000000c000000b2000000...",
  ],
  "version": "0x0",
  "witnesses": [],
}
```

The full content of the cell output data is:

```
0x
00000000b20000000c000000b2000000a2000000a3687365727669636573a16b
617470726f746f5f706473a264747970657819417470726f746f506572736f6e
616c4461746153657276657268656e64706f696e747468747470733a2f2f6578
616d706c652e746573746b616c736f4b6e6f776e4173816d61743a2f2f626f62
2e7465737473766572696669636174696f6e4d6574686f6473a167617470726f
746f736469643a6b65793a7a5369676e696e674b6579
```

It is the Molecule encoding of `DidWeb5Data` using `DidWeb5DataV1` that `local_id` is `None` and `document` is the DAG-CBOR encoding of the following JSON object:

```jsx
{
  "verificationMethods": {
    "atproto": "did:key:zSigningKey"
  },
  "alsoKnownAs": ["at://bob.test"],
  "services": {
    "atproto_pds": {
      "type": "AtprotoPersonalDataServer",
      "endpoint": "<https://example.test>"
    }
  }
}
```

### 3.6.3 Deactivation Example

```jsx
{
  "cellDeps": [
    // did-web5-ts for inputs[0]
    {
      "depType": "code",
      "outPoint": {
        "index": "0x0",
        "txHash": "0x1ecbf88d692a14d7cbc0bfd1a3d5019e4b613247ae438bad52f94148c6009559",
      },
    },
    // always-success for inputs[0]
    {
      "depType": "code",
      "outPoint": {
        "index": "0x1",
        "txHash": "0x1ecbf88d692a14d7cbc0bfd1a3d5019e4b613247ae438bad52f94148c6009559",
      },
    },
  ],
  "headerDeps": [],
  "inputs": [
    // DID Document Cell created in the Update Example
    {
      "previousOutput": {
        "index": "0x0",
        "txHash": "0x781140553ba39702e39f6d8c851512549c7b930e1cb34200ab2e1b73354eccbb",
      },
      "since": "0x0",
    },
  ],
  "outputs": [
    // The change cell to return the occupied capacity
    {
      "capacity": "0x256",
      "lock": {
        "args": "0x",
        "codeHash": "0x3dc9cdb5b2dcff8d4999004406558d4456ecf0f14c757ca353684c0bd4d3b50d",
        "hashType": "type",
      },
    },
  ],
  "outputsData": [
    "0x",
  ],
  "version": "0x0",
  "witnesses": [],
}
```

## 4. Security Considerations

### 4.1 Threat Model

The `did:web5` method operates under the following security assumptions:

- **Blockchain Security**: CKB consensus provides Byzantine fault tolerance
- **Cryptographic Primitives**: BLAKE2b and secp256k1 are secure
- **Key Management**: Users maintain secure control of private keys
- **Network Integrity**: Majority of CKB miners act honestly

### 4.2 Attack Vectors

### 4.2.1 Double-Spending Attacks

Double-Spending will break the method-specific identifier uniqueness guarantee. CKB's UTXO model and consensus mechanism prevent double-spending of Cells.

### 4.2.2 Key Compromise

User CAN use a Lock Script that mitigating the key compromise. For example:

- A multi-sign Lock Script requires multiple signatures to authorize the transaction.
- A quantum-resistant Lock Script addresses quantum computation challenges, designed to withstand potential threats.

### 4.2.3 Front-Running

The method-specific ID originates from the first input of a CKB transaction. This means that an ID is preserved for each Live Cell and Front-Running is impossible.

### 4.2.4 Denial of Service

Transaction fees and blockchain capacity limits provide economic DoS protection. The distributed architecture also increases the cost of DoS attacks.

## 5. Privacy Considerations

### 5.1 Privacy Model

The `did:web5` method provides:

- **Pseudonymous Identifiers**: DIDs do not inherently reveal personal information
- **Selective Disclosure**: Users control what information to include in DID Documents

### 5.2 Privacy Attacks

### 5.2.1 Correlation Attacks

Risk: DIDs and associated transactions may be correlated across uses.

Mitigation: Users SHOULD use multiple DIDs for different contexts and purposes.

### 5.2.2 Metadata Leakage

Risk: Transaction timing, amounts, and patterns may reveal information.

Mitigation: Use of mixing services, timing randomization, and standardized transaction patterns.

## 6. References

- [BLAKE2] Saarinen, M-J., & Aumasson, J-P. (2015). RFC 7693: The BLAKE2 Cryptographic Hash and Message Authentication Code (MAC). [https://www.rfc-editor.org/rfc/rfc7693](https://www.rfc-editor.org/rfc/rfc7693)
- [CKB] Xie, J. (2018). Nervos CKB: A Common Knowledge Base for Crypto-Economy. GitHub. [https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0002-ckb/0002-ckb.md](https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0002-ckb/0002-ckb.md)
- [DAG-CBOR] IPLD. (2022). DAG-CBOR Specification. [https://ipld.io/specs/codecs/dag-cbor/spec/](https://ipld.io/specs/codecs/dag-cbor/spec/)
- [DID-PLC] Bluesky. (2023). did:plc Specification v0.1. [https://web.plc.directory/spec/v0.1/did-plc](https://web.plc.directory/spec/v0.1/did-plc)
- [DID-SPEC] Sporny, M., Longley, D., Sabadello, M., Reed, D., Steele, O., & Allen, C. (2022). Decentralized Identifiers (DIDs) v1.0. [https://www.w3.org/TR/did-1.0/](https://www.w3.org/TR/did-1.0/)
- [MOLECULE] Nervos Network. (2019). Molecule, Another serialization system: minimalist and canonicalization. GitHub. [https://github.com/nervosnetwork/molecule](https://github.com/nervosnetwork/molecule)
- [RFC2119] Bradner, S. (1997). RFC 2119: Key words for use in RFCs to Indicate Requirement Levels. [https://www.rfc-editor.org/rfc/rfc2119](https://www.rfc-editor.org/rfc/rfc2119)
- [RFC4648] Josefsson, S. (2006). The Base16, Base32, and Base64 Data Encodings. [https://www.rfc-editor.org/rfc/rfc4648.html](https://www.rfc-editor.org/rfc/rfc4648.html)

## Appendix

### Appendix A: Introduction to CKB Cell Model

### A.1 UTXO Evolution: From Bitcoin to CKB

CKB employs an evolved version of Bitcoin's UTXO (Unspent Transaction Output) model, called the Cell model. In traditional UTXO systems, each transaction output has a fixed value and a script that sets conditions for spending. CKB extends this concept with Cells, which can store not only value but also arbitrary data and executable code.

The Cell model represents a fundamental shift from the account-based model used in systems like Ethereum, to a state-centric architecture where state transitions are represented directly in transactions. This approach offers significant advantages for identity management systems like DIDs.

### A.2 Cell Structure

A Cell in CKB is a basic unit of storage and has the following components:

- **Capacity**: Measured in CKBytes, this represents both the monetary value and the storage space available in the Cell. One CKByte token entitles the holder to one byte of data storage on the blockchain.
- **Data**: The arbitrary binary content stored in the Cell. This can include the DID document.
- **Lock Script**: A mandatory script that controls the ownership and access to a Cell. This ensures only authorized users can consume/spend the Cell.
- **Type Script**: An optional script that defines the rules for state transitions, essentially controlling how a Cell can be used or modified in a transaction.

### A.3 Live and Dead Cells

Cells are immutable once created on the blockchain. The state update mechanism follows these principles:

- **Live Cell**: A Cell that has been created but not yet consumed. Only Live Cells can be used in new transactions.
- **Dead Cell**: A Cell that has been consumed by a transaction. Once a Cell is dead, it cannot be used again.

When updating data in a Cell (such as modifying a DID Document), the original Cell must be consumed (destroyed), and a new Cell with the updated data must be created, maintaining the same identifier to represent continuity of the entity.

### A.4 Transaction

A transaction in CKB represents a state transition that consumes some existing Cells as inputs and creates new Cells as outputs.

A transaction's validity is enforced through the scripts contained in the Cells. This verification process ensures the transaction complies with all rules defined in the Cells' Lock and Type Scripts.

### A.5 Consensus

The CKB NC-Max Consensus determines the total order of transactions and ensures that:

- A Cell can only be spent once.
- A Cell can only be spent after being created.

### Appendix B: Test Vectors

### B.1 Method-Specific Identifier Generation

Python script that generates the identifier:

```python
import hashlib
import base64

def ckbhash():
    return hashlib.blake2b(digest_size=32, person=b'ckb-default-hash')

hasher = ckbhash()
# inptus[0].since = 0
hasher.update((0).to_bytes(8, byteorder='little'))
# inputs[0].previous_output.tx_hash
hasher.update(bytes.fromhex('1ecbf88d692a14d7cbc0bfd1a3d5019e4b613247ae438bad52f94148c6009559'))
# inputs[0].previous_output.index = 2
hasher.update((2).to_bytes(4, byteorder='little'))
# DID Document Cell output index
hasher.update((0).to_bytes(8, byteorder='little'))

identifier_hex = hasher.hexdigest()[:40]
print(identifier_hex)
# => 8434cfe81aa825c275d513eee20e4235294e3420

print(base64.b32encode(bytes.fromhex(identifier_hex)).decode('utf-8').lower())
# => qq2m72a2vas4e5ovcpxoedscguuu4nbav
```

### B.2 DID Document Cell Data Encoding

Assume that the DID document is:

```jsx
{
  "verificationMethods": {
    "atproto": "did:key:zSigningKey"
  },
  "alsoKnownAs": ["at://alice.test"],
  "services": {
    "atproto_pds": {
      "type": "AtprotoPersonalDataServer",
      "endpoint": "<https://example.test>"
    }
  }
}
```

The DAG-CBOR encoding is:

```
0x
a3687365727669636573a16b617470726f746f5f706473a26474797065781941
7470726f746f506572736f6e616c4461746153657276657268656e64706f696e
747468747470733a2f2f6578616d706c652e746573746b616c736f4b6e6f776e
4173816f61743a2f2f616c6963652e7465737473766572696669636174696f6e
4d6574686f6473a167617470726f746f736469643a6b65793a7a5369676e696e
674b6579
```

If `local_id` is `None`, the Molecule encoding of the cell data is:

```
0x
00000000b40000000c000000b4000000a4000000a3687365727669636573a16b
617470726f746f5f706473a264747970657819417470726f746f506572736f6e
616c4461746153657276657268656e64706f696e747468747470733a2f2f6578
616d706c652e746573746b616c736f4b6e6f776e4173816f61743a2f2f616c69
63652e7465737473766572696669636174696f6e4d6574686f6473a167617470
726f746f736469643a6b65793a7a5369676e696e674b6579
```

### Appendix C: Implementation Considerations

### C.1 did-web5-ts Type Script

Use Molecule strict mode for reading cell data and witness. Note that witness compatibility isn't required, while cell data compatibility is already handled by `union`.
